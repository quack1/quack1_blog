Title: &#35;SSTIC 2014 - Dernier jour..
Date: 2014-06-11 09:30 
Author: Quack1
Category: S√©curit√©
Tags: S√©curit√©, SSTIC, SSTIC 2014, Job, planet-libre
Slug: sstic_2014_3
Summary: #SSTIC 2014, dernier jour de la conf√©rence
Lang: fr

Derni√®re journ√©e du [#SSTIC 2014](/tag/sstic-2014.html), un peu moins charg√©e que les autres. Mais bon, ¬´ grosso modo ¬ª[^1], c'est parce qu'il faut bien que les parisiens prennent leur train ;)

# √âlaboration d'une repr√©sentation interm√©diaire pour l'ex√©cution concolique et le marquage de donn√©es sous Windows par S√©bastien Lecomte

[Article](https://www.sstic.org/media/SSTIC2014/SSTIC-actes/representation_intermediaire_de_code_windows/SSTIC2014-Article-representation_intermediaire_de_code_windows-lecomte.pdf) et [Slides](https://www.sstic.org/media/SSTIC2014/SSTIC-actes/representation_intermediaire_de_code_windows/SSTIC2014-Slides-representation_intermediaire_de_code_windows-lecomte.pdf)

Fuzzgrind est un fuzzer intelligent qui permet de faire de la couverture de code et peut trouver des vuln√©rabilit√©s dans le code. 1/3 des failles de Windows 7 auraient √©t√© d√©couvertes de cette fa√ßon.

L'orateur pr√©sente un portage de Fuzzgrind vers Windows, en utilisant PIN Tools pour instrumenter le fuzzer. Sauf qu'il faut aussi marquer les donn√©es pour suivre leur √©volution au cours de l'√©x√©cution du programme. L'orateur pr√©sente les valeurs qu'il choisi de marquer ainsi que les m√©thodes qu'il utilise.

# Obfuscation de code Python : am√©lioration des techniques existantes par Ninon Eyrolles & Serge Guelton

[Article](https://www.sstic.org/media/SSTIC2014/SSTIC-actes/obfuscation_de_code_python__amlioration_des_techni/SSTIC2014-Article-obfuscation_de_code_python__amlioration_des_techniques_existantes-eyrolles_guelton.pdf)

(Encore) une pr√©sentation de Quarkslab, cette fois sur l'obfuscation de code Python. Puisque Python est un langage interpr√©t√©, il est peu obscurssi. Les deux conf√©renciers pr√©sentent plusieurs techniques pour obscurssir du Python.

On peut obfusquer du code Python √† trois niveaux : 

- Modifier l'interpr√©teur ;
- Obscurssir le code source ;
- Mixer les deux.

Ils ont pour cela √©crit un outil, Python-pack, disponible sur le Github de Quarkslab.

En touchant √† l'interpr√©teur, il est possible de le modifier pour, par exemple, transrormer les _opcodes_ √† l'√©x√©cution, ou en rajouter. Par exemple, une addition dans la source sera finalement consid√©r√©e comme une soustraction √† l'ex√©cution. Un [billet de blog](http://blog.quarkslab.com/building-an-obfuscated-python-interpreter-we-need-more-opcodes.html) pr√©sentait d√©j√† un peu √ßa.

Ensuite, on peut √©galement modifier le code source. Par exemple, en rajoutant un m√©thode `modify()` avant certaines op√©rations. Cette fonction va, √† l'√©x√©cution, transformer les quelques lignes de code qui suivent. Par exemple, le code suivant : 

	:::Python
	modify()
	b -= 1

pourra √™tre finalement interpr√©t√© comme :

	:::Python
	b += 1

√† l'√©x√©cution. De cette mani√®re, on peut ruiner (ou au moins ralentir) les analyses statiques.

On peut aussi utiliser plein de _tricks_ un peu sympa, comme changer tous les noms de variables et fonctions, remplacer les `if` en `while` avec des pr√©dicats plus complexes et opaques, modifier le code des fonctions pour le rendre impossible √† lire (notamment en utilisant des `lambda`), etc.

<div align=center><a href="/upload/sstic_obfus_python.jpg"><img src="/upload/sstic_obfus_python.jpg" align=center width="400"/></a></div>

Plus d'exemples sont disponibles dans les actes.

# D√©sobfuscation de DRM par attaques auxiliaires par Camille Mougey & Francis Gabriel

[Article](https://www.sstic.org/media/SSTIC2014/SSTIC-actes/dsobfuscation_de_drm_par_attaques_auxiliaires/SSTIC2014-Article-dsobfuscation_de_drm_par_attaques_auxiliaires-mougey_gabriel.pdf) et [Slides](https://www.sstic.org/media/SSTIC2014/SSTIC-actes/dsobfuscation_de_drm_par_attaques_auxiliaires/SSTIC2014-Slides-dsobfuscation_de_drm_par_attaques_auxiliaires-mougey_gabriel.pdf)

Un DRM c'est fait pour ne pas √™tre compris par les ¬´ profanes ¬ª. Le code est donc tr√®s souvent obfusqu√© et impossible √† comprendre. Au menu, les paquets r√©seaux sont obscurssis, le bytecode est aplati, les _magic blocks_ sont d√©coup√©s en des morceaux plus petits, etc.

√Ä cause de toutes ces mesures, analyser tout le flux d'√©x√©cution d'un DRM est trop co√ªteux (en m√™me temps, c'est un peu le but aussi üòâ ). Les deux orateurs ont donc d√©cid√© de se concentrer sur une seule √©x√©cution pour comprendre le fonctionnement du DRM.

Ils ont pour cela d√©velopp√© un outil, pTrap (pour ¬´ **P**ython **TR**ace **A**nalyzer ¬ª). Cet outil traite une trace d'execution, fourni une API qui permettra de manipuler la trace et stocke la trace dans une base de donn√©es MongoDB, qui pourra √™tre r√©cup√©r√©e par Intel PIN, Miasm, IDA, ou encore ollydbg.

Le but est de retrouver des petites briques de code qui permettront de comprendre l'algorithme, la crypto, les m√©canismes de d√©rivation, etc, de trouver les blocs statiques qui contiennent les constantes cryptographiques (pour SHA, AES, etc) et finalement d'identifier les fonctions appel√©es.

L'approche principalement utilis√©e ici est, une fois qu'on a trouv√© des blocs, de choisir un bloc de ¬´ fin ¬ª, trouver ses _I/O_, puis de remonter aux fonctions appelantes. On peut de cette fa√ßon retracer tout le programme.

# R√©sultat du challenge 	

Cette ann√©e, 20 personnes ont valid√© le challenge, mais seulement 16 solutions ont √©t√© retenues (les autres √©taient membres du CP). La validation la plus rapide a √©t√© 4 jours, les quelques r√©solutions suivantes l'ont √©t√© dans les 5 jours.

Le challenge √©tait compos√© de trois parties : 

1. une trace USB r√©alis√©e avec un appareil Android et _usbmon_ ;
2. Un _crackme_ en ARM64 obfusqu√© ;
3. Un micro-contr√¥leur _remote_ √©crit en Ruby qu'il fallait casser.

Guillaume Delugr√© √† mis [sur Github](https://github.com/gdelugre/challenge-sstic-2014) les scripts qu'il a utilis√© pour g√©n√©rer le challende.

**R√©solution**

J'ai pas compris toutes les √©tapes de la r√©solution, [@G4l4drim](https://twitter.com/G4l4drim) a fait √ßa mieux que moi [sur son blog](http://www.n0secure.org/2014/06/sstic-2014-jour-3.html).

# Exemple de renforcement de la s√©curit√© d'un OIV par Victor Vuillard

Longue pr√©sentation sur la s√©curit√© des ¬´ Op√©rateurs d'Importance Vitale ¬ª (ou OIV), et plus pr√©cis√©ment des centrales nucl√©aires d'EDF.

La s√©curit√© dans ce milieu semble plus prise au s√©rieuse que dans les autres milieux, puisque ici le moindre incident de s√©curit√© √† des impacts imm√©diats et graves (Stuxnet ?). Les RSSI et DSI ont donc des approches plus simples, claires et efficaces de la s√©curit√©, contrairement √† certaines autres m√©thodologies (2700X ?).

Sur des gros p√©rim√®tres comme ceux d'EDF et des centrales, on retrouve cependant des syst√®mes souvent tr√®s h√©t√©rog√®nes. Le parc est souvent issu du regroupement de plusieurs soci√©t√©s rachet√©es par la maison m√®re, il est compos√© de machines fabriqu√©es par des constructeurs diff√©rents, des √©quipes diff√©rentes pilotent ces √©quipements, etc.

En revanche, la s√ªret√© est beaucoup plus avanc√©e sur ces plateformes. Des m√©canismes sous-jacents et int√©gr√©s aux machines permettent de d√©tecter et emp√™cher certains cas malveillants de survenir. Par contre, il existe √©galement des contraintes sur le temps d'√©x√©cution (temps contraint, temps r√©el) qui emp√™che de mettre en places certaines protections comme des authentifications fortes, de la crypto, etc. Mais comme la division SSI est rattach√©e √† la s√ªret√©, elle peut plus facilement faire mettre en place certaines bonnes pratiques.

# Pr√©sentation courte: S√©curit√© de la gestion dynamique des ressources dans le cloud : prise de contr√¥le sur le d√©clenchement de migrations automatiques de machines virtuelles par Haiming Zheng & Jalel Ben-Othman & Kahina Lazri & Sylvie Laniepce

[Article](https://www.sstic.org/media/SSTIC2014/SSTIC-actes/scurit_de_la_gestion_dynamiqu_cloud/SSTIC2014-Article-scurit_de_la_gestion_dynamiqu_cloud-zheng_ben-othman_lazri_laniepce.pdf)

Le cloud, c'est le royaume des machines virtuelles. Le probl√®me avec des VM est que, en th√©orie, pour faire tourner 3 _guests_ qui ont chacun 2Go de RAM et 2 coeurs, il faut normalement un _host_ de minimum 6Go de RAM et 6 coeurs (plus les ressources pour faire tourner l'hyperviseur).

Donc √ßa revient souvent trop cher d'acheter de tels serveurs, tout en sachant que g√©n√©ralement les VM n'utilisent pas la moiti√© des ressources qui leur sont allou√©es. Une solution a donc √©t√© trouv√©e chez les hyperviseurs : prendre des _hosts_ moins puissants[^2], puis distribuer les ressources √† la demande aux VM, quand l'une d'entre elles en √† besoin.

Et quand une VM demande trop de ressources, l'hyperviseur d√©place une des machines moins gourmandes sur un autre _host_, pour lib√©rer sur le premier des ressources pour le _guest_ trop gourmand.

On peut donc de cette fa√ßon, en contr√¥lant une VM malveillante qui demandera toujours plus de ressources, entra√Æner l'hyperviseur √† d√©placer sans cesse les autres machines sur d'autres _hosts_, ce qui va donc causer des baisses de performances sur ces machines.

Et si une VM malveillante ne suffit pas, on peut √©galement en contr√¥ler deux sur deux hosts diff√©rents (mettons _A_ et _B_), pour que l'hyperviseur d√©place, sans arr√™t, des VM de _A_ vers _B_ et des VM de _B_ vers _A_.

Et le bonus, c'est que lorsque l'hyperviseur d√©place une VM, il consomme 30% de la RAM de la VM en plus. On peut comme √ßa faire tourner l'hyperviseur en bourrique.

# Pr√©sentation courte : RpcView : un outil d'exploration et de d√©compilation des MS RPC par Jean-Marie Borello & J√©r√©my Bou√©tard & Julien Boutet & Yoanne Girardin

Pr√©sentation de [RpcView](http://www.rpcview.org), un outil qui permet de visualiser des RPC Microsoft, de les d√©compiler puis de les analyser, les modifier et les rejouer. Une d√©mo live nous montre comment on peut demander avec l'outil √† plusieurs Stuxnet de se d√©sinstaller.

# Pr√©sentation courte : Haka : un langage orient√© r√©seaux et s√©curit√© par Kevin Denis & Mehdi Talbi & Paul Fariello & Pierre Sylvain Desse 

[Article](https://www.sstic.org/media/SSTIC2014/SSTIC-actes/haka_software_defined_security/SSTIC2014-Article-haka_software_defined_security-denis_talbi_fariello_desse.pdf)

Haka est nouveau langage permettant de d√©crire des r√®gles de s√©curit√©. Il se compose de deux parties : 

1. des dissecteurs, qui analysent des flux r√©seaux (NFQueue ou pcap) et d√©coupe ces paquets en ¬´ objets ¬ª manipulables dans les r√®gles. Par exemple, pour HTTP, tous les ent√™tes (_Host_, _User-Agent_, etc) seront disponibles pour √©crire des filtres ;
2. les r√®gles de s√©curit√© proprement dites sont donc des filtres qui seront √©crits √† partir des protocoles pr√©c√©dement analys√©s. Il est possible de filtrer les paquets re√ßus, de lancer des actions sur le syst√®me (filtrage, etc) ou encore modifier les paquets.

C'est [open-source](http://haka-security.org/) pour ceux qui veulent tester, perso je vois pas de diff√©rences avec [Suricata](http://suricata-ids.org/), √† part que √ßa doit moins bien tenir la charge mais que les dissecteurs ont l'air plus simples √† √©crire...

# Tutorial Miasm par Fabrice Desclaux

Cette ann√©e, pas de conf√©rence de cl√¥ture, mais un tutorial sur [miasm](https://code.google.com/p/miasm) donn√© par Fabrice Desclaux et <s></s>son stagiaire.

Une fois pass√©e la [difficile √©tape d'installation](/sstic_2014_2_rumps.html#tuto-miasm-par-serpi-fabrice-desclaux), miasm a l'air d'√™tre un outil assez utile pour faciliter le _reverse_ de binaires.

Pour ce tutorial, une [proc√©dure d'installation compl√®te](http://code.google.com/p/miasm/) et une [archive contenant des binaires/scripts de tests](http://droids-corp.org/m2_pkg.tgz) ont √©t√© fournis par serpy.

Miasm est donc un ¬´ framework Python ¬ª qui permet d'instrumenter la fa√ßon dont seront _revers√©s_ des binaires pour faciliter la lecture du bytecode. Fabrice Desclaux nous fait donc une d√©mo live (et en parlant tr√®s, tr√®s, tr√®s, ..., tr√®s vite) en partant d'un binaire brut et en am√©liorant √† chaque √©tape sa lisibilit√©. 

Miasm peut supprimer et regrouper des basic blocks, aplatir de graphe de code ou au contraire le re-transformer en quelque chose de lisible, supprimer les portions de code inutiles, etc... Et √† la fin, il est m√™me possible de lancer le d√©bug dans miasm, mais de _plugger_ IDA dessus pour suivre l'√©x√©cution dans IDA tout en profitant des fonctionnalit√©s de miasm. Si on reprend les expressions f√©tiches de serpy, je pense que ¬´, mon petit poussin, grosso modo, une fois que miasm a enlev√© tout le merdier qui sert √† rien ¬ª, on a un binaire vraiment exploitable.

¬´ Grosso modo ¬ª, c'est un bon outil miasm \o/

<blockquote class="twitter-tweet" lang="fr"><p><a href="https://twitter.com/search?q=%23miasm&amp;src=hash">#miasm</a> <a href="https://twitter.com/search?q=%23sstic&amp;src=hash">#sstic</a> (version inline pour ceux qui n&#39;aiment pas cliquer sur les liens :) <a href="http://t.co/TS3XmAoVC2">pic.twitter.com/TS3XmAoVC2</a></p>&mdash; newsoft (@newsoft) <a href="https://twitter.com/newsoft/statuses/474916294840844288">6 Juin 2014</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


[^1]: _Private Joke_, vous comprendrez √† la fin de l'article...

[^2]: On a `SUM(VM.ressources) > Host.ressources`