Title: Test de pénétration d'une application Web (avec client Flash)
Date: 2013-02-21 10:12
Author: Quack1
Category: pentest
Tags: pentest, sécurité, web, webapp, flash, flex, pyamf, burp

# Résumé

Un audit de la sécurité d'une application Web est un processus long, coûteux en temps et en compétences, mais surtout très spécifique à chaque application auditée.

En effet, même si les bases de l'évaluation peuvent être communes à tous les Systèmes d'Information, les spécificités dans le déploiement et la configuration de chacun forcent les auditeurs à repenser à chaque fois les méthodes utilisées et mises en place dans leur audit.

Cependant cette méthode, une fois adaptée à une nouvelle cible, pourra être réutilisée dans d'autres audits de ce type.

Au cours de mon master en Sécurité Informatique ([Master CRYPTIS, Limoges](http://cryptis.fr)), un projet de [pentest](./tag/pentest.html) de l'application Web d'une entreprise partenaire nous a été proposé par notre enseignant [@kartoch](http://twitter.com/kartoch).
Nous allons ici tenter de détailler la démarche utilisée pour évaluer la sécurité de cette cible, de la découverte complète de l'application Web jusqu'à l'exploitation des failles découvertes.

&nbsp;

En guise d'introduction, il convient de présenter rapidement le but d'un audit. Vous pouvez pour cela lire l'introduction de ma série sur le [pentest](./pentest-0-introduction.html), ou bien lire ma prose ici ;-)

Le but de ce projet était donc de réaliser l'audit de sécurité d'une application Web. Le but d'un audit n'est pas de déterminer si un produit ou système est sécurisé ou non, mais plutôt de lister les vulnérabilités présentes sur ce système et découvertes lors de l'audit.

L'audit a ici réalisé en _Grey-Box_, puisqu'aucune information sur le système cible n'était connue des auditeurs, mais nous pouvions cependant nous créer des comptes sur l'application Web. Nous avions donc un point d'entrée officiel et légal sur celle-ci. 

Enfin, l'application est un système de travail collaboratif, permet à des utilisateurs de travailler en commun sur des projets via des modules de gestion de tâches, d'un fil de discussion et d'un système de partage de fichiers.

&nbsp;
_Afin de respecter la confidentialité de la société, ainsi que des résultats de cet audit, toutes les références à cette entreprise ont été anonymisées._




# Découverte globale de l'environnement

La première étape, et sûrement la plus importante, lors de tout test d'intrusion, est de récolter le maximum d'informations concernant la cible à auditer.



## Reconnaissance système et réseaux

Une information très importante est l'adresse IP publique de l'application Web. Cette information se récupère très simplement au moyen de la commande `dig} qui va interroger les serveurs DNS afin d'obtenir l'adresse IP associée à l'hôte audité. On peut voir sur la figure suivante que l'adresse IP du serveur hébergeant l'application BatSignal est `0.0.0.0}.

<div align=center><a href="static/upload/nba_dig_A.png"><img src="static/upload/nba_dig_A.png" align="center"/></a><br/>Résultat de la commande `dig` sur le domaine wayne.com</div>
		
L'adresse IP pourra nous permettre de vérifier, grâce aux enregistrements DNS, si l'application est hébergée sur un service d'hébergement mutualisé ou sur un hébergement dédié. On pourra de cette manière limiter les attaques lancées, comme les tests de montée en charge ou d'autres tests qui pourraient occasionner des dommages sur les applications "voisines", si la cible partage son environnement avec d'autres services.
Dans notre cas, nous avons su des administrateurs de Wayne Enterprises que BatSignal est hébergée dans le "cloud" d'Amazon, _Amazon Web Services_ (AWS). Cette étape n'est donc pas nécéssaire.

&nbsp;
Une deuxième étape de reconnaissance est la découverte des services lancés sur le serveur distant et accessibles depuis l'Internet. Cette phase permet d'obtenir des informations sur la machine et les logiciels qui font tourner l'applications web auditée, et permettra donc d'affiner les attaques lancées et/ou de lancer des attaques sur l'application spécifiques au logiciel sous-jacent.
		
Un tel scan peut être lancé grâce au logiciel `nmap` (Projet nmap : `http://nmap.org`), qui va : 

1. Tenter d'ouvrir des connexions sur "chaque" port de la machine ;
2. Récupérer des informations sur le serveur (OS, IP, nom d'hôte).

La figure qui suit présente le lancement de `nmap` sur le serveur `demo.wayne.com`. On rajoute certaines options par rapport à un lancement standard :

- `--scan-delay=2s` : Afin de diminuer la probabilité de détection sur l'hôte distant, un délai de 2 secondes est rajouté entre chaque lancement de scan de port ;
- `-sV` : Pour pouvoir vérifier l'existence de vulnérabilités sur les logiciels présents sur le serveur, on demande à `nmap` d'afficher les versions des logiciels lancés;
- `-O` : Enfin, `nmap` va tenter de déterminer le Système d'Exploitation présent sur l'hôte distant.

<div align=center><a href="static/upload/nba_nmap.png"><img src="static/upload/nba_nmap.png" align="center"/></a><br/>Résultat de la commande `nmap` sur le domaine wayne.com</div>

&nbsp;
Ces deux premières étapes sont les seules étapes réalisées sans contact direct avec l'application auditée. Nous verrons cependant dans une partie suivante que ces informations, notamment celles découvertes grâce à `nmap`, seront très utiles au cours de l'audit.

&nbsp;
Il est possible de rajouter ici une partie de reconnaissance nommée **OSINT**, ou _Open-Source Intelligence_, qui consiste à récupérer sur internet, notamment sur les réseaux sociaux, des informations concernant l'entreprise auditée et les clients/utilisateurs des applications. Cette étape est particulièrement utile dans le cas où du _Social Engineering_ est réalisé. N'ayant pas réalisé cette étape lors de ce projet, nous n'en reparlerons pas ici, mais un article plus détaillé sera bientôt publié sur mon blog (via [la série consacrée au pentest](./tag/serie_pentest.html "Tag : serie_pentest")).



## Découverte du fonctionnement de l'application

Nous allons désormais réaliser une découverte globale de l'application Web à auditer, afin d'appréhender de façon complète son fonctionnement, de manière à pouvoir commencer à imaginer des scénarios d'attaques visant cette cible.

L'application Web est accessible à l'url `https://demo.wayne.com`. On s'aperçoit ici qu'elle n'est accessible **uniquement** en `https`, ce qui ajoute une couche de protection lors du transfert des données entre le serveur et le client.

Le deuxième point visible au moment de l'accès à l'application est que la partie utilisateur est entièrement développée en _Flex_, nécéssitant _Adobe Flash Player_. Ceci va permettre d'utiliser des techniques d'audit différentes des techniques "nomales" d'audit d'un service Web donc l'interface utilisateur utilise des technologies Html/CSS/Javascript.
En effet, nous verrons dans la partie concernant les attaques sur _AMF_ que nous ne pouvons utiliser des mécanismes de _scripting_ "simples" d'envoi de données Http.


&nbsp;
La reconnaissance "technique" effectuée, nous allons passer à une reconnaissance de la "logique" de l'application Web.

Outre les tentatives d'attaques sur le serveur ou les services en écoute sur celui-ci, la principale motivation d'un attaquant est de déjouer les mécanismes de sécurité mis en place afin d'effectuer des actions qu'il ne serait normalement pas en mesure d'effectuer.

Il faut donc, pour cela, avoir une bonne connaissance du fonctionnement global et avancé de l'application Web, et en particulier des actions que chaque utilisateur pourra effectuer, mais surtout que celui-ci ne **pourra pas** effectuer. On pourra ainsi préparer lors de cette étape d'inspection les grandes lignes des scénarios d'attaque qui seront utilisés lors des tests de pénétration.

Il va donc falloir utiliser les services proposés par l'application et tester le maximum de fonctions présentes, depuis le premier accès d'un utilisateur sur le site, jusqu'aux mécanismes de configuration et d'utilisation plus avancés.


&nbsp;
À la fin de la reconnaissance globale de l'application, nous avons une vision globale du système cible, nous connaissons son organisation, son fonctionnement, ainsi les actions qu'il est possible de réaliser en tant qu'utilisateur de l'application.



# Découverte détaillée de l'application Web
	
La première étape de reconnaissance nous a permis d'obtenir une vue très globale de l'application, de très haut niveau. C'est à dire que nous n'avons vu que la partie "visible" de l'iceberg. L'utilisation de Flash en tant que partie cliente implique qu'il devient difficile pour les auditeurs d'avoir accès à aux mécansimes de fonctionnement sous-jacent de l'application, et en particulier le format des messages transmis entre le client et le serveur.

De plus, afin de pouvoir auditer l'application, il faudra être en mesure de pouvoir modifier les données envoyées au serveur en "bypassant" les protections et modifications effectuées par le client Flash.

La méthode généralement employée est la modification des données _POST_ ou _GET_ de http. Cependant, dans le cas de Flash, ceci est plus complexe puisque les données transitent via les en-têtes http, mais encodées au format AMF, spécifique à Flash.

Nous avons donc deux défis afin de pouvoir intercepter et modifier les données envoyées vers le serveur : 

1. Décoder le format AMF "à-la-volée", les modifier, les ré-encoder et les envoyer ;
2. Intercepter ses données à l'intérieur du tunnel SSL entre le client Flash et le serveur.


Nous utilisons pour cela le logiciel _Burp Suite_, en version gratuite.

Ce logiciel va se placer en tant que proxy sur la machine locale, se faisant passer : 

- vu du client : pour le serveur, en lui envoyant son propre certificat SSL ;
- vu du serveur : pour le client lui-même.

De cette façon, on réalisera au moyen de Burp une attaque dite, "Man-In-The-Middle".

<div align=center><a href="static/upload/mitm.jpg"><img src="static/upload/mitm.jpg" align="center"/></a><br/>Illustration d'une attaque par "Man-In-The-Middle". Source : OWASP. `https://www.owasp.org/index.php/File:Main_the_middle.JPG`</div>

En interceptant les données dans Burp, il est possible de voir, mais surtout de modifier ce qui est transmis au serveur. On peut voir dans la figure suivante le format utilisé.

<div align=center><a href="static/upload/amf_data.png"><img src="static/upload/amf_data.png" align="center"/></a></div>

Ce format est relativement simple. Les champs importants ici sont : 

- `target`, qui défini la cible sur le serveur qui va traiter les messages ;
- `response`, qui correspond au type de réponse envoyée ;
- `data`, qui contient les données spécifiques à l'application envoyées par le client. On note ici les valeurs : 
	- `project` : l'identifiant du projet concerné sur BatSignal ;
	- `requestToken` : Token d'identification ;
	- `service` et `method` : Fonction appelée sur le service distant (_concept proche de `<anObject.aMethod(args);>`_);
	- `arguments` : Arguments de la méthode appelée.

C'est par le biais de Burp que nous allons pouvoir "mapper" en détails le fonctionnement de l'application, afin de pouvoir auditer les services de l'application distante. 
Nous allons donc passer en revue chacun des liens de l'application, chacune des méthodes qui envoie des données au serveur, afin d'obtenir la totalité des fonctions disponibles sur le serveur.

Lors de l'attaque, on pourra alors aisément auditer la sécurité de la logique des méthodes du serveur, puisque leur fonctionnement aura été analysé en amont.


&nbsp;
Enfin, nous possédons donc une vue complète de l'application, de son fonctionnement générale jusqu'aux entrailles des méthodes distantes du serveur.
Nous pouvons donc commencer à imaginer des scénraios d'attaques contre cette application Web et son serveur.





# Scénarios d'attaques


Nous avons, dans la partie concernant la reconnaissance système et réseaux, découvert le système distant, son système d'exploitation ainsi que les services lancés sur cette machine et en écoute sur l'Internet.

Dans les parties concernant le fonctionnement de l'application et la découverte de l'application Web, nous avons pu observer le fonctionnement détaillé de notre cible.

À ce moment, des scénarios d'attaques commencent à se profiler, tant au niveau logiciel, qu'au niveau applicatif. Nous allons donc ici présenter ces scénarios d'attaque, en commencant par les attaques visant le système, puis les attaques sur la logique de l'application.
	

## Attaques sur le système distant

Nous avons, dans l'image précédente illustrant le lancement de `nmap`, listé les services disponibles sur ce serveur et en écoute sur Internet.

Ces services sont de différentes sortes, mais cependant restent très standards pour une application de ce type. Cependant, il est très difficile de prévoir les attaques sur ces composants.

On pensera quand même à vérifier qu'aucune faille exploitable (ou CVE) n'aura été publiée sur Internet pour la version du serveur Apache présente sur l'hôte distant.

On pourra également tester si des défauts dans la configuration d'Apache sont présentes et exploitables afin d'obtenir un accès et un contrôle du serveur et/ou de la machine distante.

Enfin, on observe une spécifité, dont nous avons été informés lors des réunions pré-audit. L'application s'exécutant sur le serveur est développée en langage Java. On peut donc très raisonnablement penser qu'un serveur Tomcat est présent. On cherchera donc à exploiter, lors de l'audit, des failles spécifiques à ce logiciel sur l'hôte distant.


## Attaques Web

Attaquant une application Web, il sera évident et indispensable de tester toutes les attaques Web "standards", comme les injections SQL, les _Path Traversal_, ou les attaques logiques. 

Les deux premières sont relativements connues et bien documentées sur Internet. Pour cette raison, nous ne les aborderons que très succintement plus tard dans cet article. 

Les attaques logiques consistent à tenter d'effectuer des actions qui ne sont d'ordinaire pas autorisées par l'application, notamment en _fuzzant_ les paramètres des méthodes appelées (c'est à dire en envoyant des données que le serveur ne s'attend pas à recevoir afin de vérifier que les contrôles sur les données d'entrée sont suffisament effectués).

Je pense que vous aurez sûrement noté que nous n'avons pas parlé ici des attaques XSS et CSRF, couramment utilisées lors des audits Web. Ceci vient de la particularité de notre application : un client Flash.
Pour cette raison, ces 2 attaques sont impossibles : 

- CSRF : Nous verrons dans la partie suivante que la configuration du serveur AMF rend le _scripting_ de l'envoi de données très complexe ;
- XSS : Le client étant en Flash, il est impossible de lui faire afficher et éxecuter du code dynamiquement.


## Attaques sur AMF

Enfin, le coeur de l'application est basé sur l'AMF, qui permet d'envoyer les données au serveur. 
On aura ici 2 méthodes d'attaque : 

- Des attaques Web, comme les injections SQL (SQLi) ou les _Path Traversal_
- Des attaques sur la logique de l'application, comme par exemple accéder à des projets dont on ne fait pas partie.

Les injections SQL sont des attaques visant à modifier les requêtes SQL exécutées sur le système de gestion de base de données afin de corrompre ou récupérer des informations de la base de données.

Les _Path Traversal_ sont des attaques qui ont pour but de récupérer des fichiers stockés hors du répertoire dans lequel s'exécute le serveur Web.

Enfin, les attaques sur la logique vont consister en l'envoi de données que le serveur ne s'attend pas à recevoir ou qu'il ne vérifiera pas et qui nous permettront d'accéder à des données non accessibles d'ordinaire. Typiquement, cela consistera à modifier les données envoyées dans les requêtes au serveur en lui passant, par exemple, les nom d'un fichier qui ne nous appartient pas, afin que le serveur nous le renvoie en se basant sur la confiance qu'il a dans la sécurité du logiciel client.

&nbsp;
Le challenge était ici de pouvoir envoyer les données au format AMF au serveur de façon simple et légère. Une première solution était d'utiliser la librairie _[pyAMF](http://www.pyamf.org/index.html)_ de Python, qui permet d'envoyer simplement des messages encodés en AMF à un serveur distant.

Cependant, pyAMF permet d'envoyer des messages formatés tels que présenté dans la figure suivante.


<div align=center><a href="static/upload/flex-sample.jpg"><img src="static/upload/flex-sample.jpg" align="center"/></a><br/>Avec la permission de Damien Cauquil (Sysdream, @virtualabs). [Source](http://virtualabs.fr/Pentest-d-applications-Flex)</div>


Cependant, on a vu dans la figure plus haut présentant le format de nos messages que les appels AMFRPC envoyés au serveur de notre application Web sont totalement différents. 
Nous avons pendant un temps envisagé de modifier la librairie afin de prendre en compte notre format de données, puis nous avons préféré réaliser nos attaques directement depuis Burp, qui nous permet de facilement modifier les données transmises et de rejouer à l'infini ces jeux de données. Ainsi, nous pouvions effectuer l'audit plus simplement, même si cela imposait de lancer Burp au lieu de pouvoir scripter l'envoi des données.


&nbsp;
&nbsp;
Nous avons ici présenté la façon dont nous avons audité l'application, depuis la reconnaissance globale de celle-ci jusqu'à l'audit de la logique de l'application, en passant par une reconnaissance de toutes les fonctions accessibles pas les clients Flash.

 Nous n'avons cependant pas parlé des vulnérabilités découvertes, ni des scénarios très spécifiques de réalisations des attaques sur celles-ci, puisque cela est très spécifique à notre cible et que cela pourrait nuire à la confidentialité de notre partenaire.

Enfin, nous allons conclure avec 2 citations que nous trouvions intéressantes dans le cadre des audits et tests d'intrusions.

> La sécurité est un échec
_Nicolas Ruff @ SSTIC 2009_

> L'attaquant gagnera toujours
_Eric Diehl @ Limoges 2012_

La sécurité de nos applications et systèmes est aujourd'hui plutôt bonne, mais dans tous les cas un attaquant arrivera à infecter nos systèmes et à corrompre les données. L'important est donc de détecter les intrusions et les attaques, et surtout de réagir le plus rapidement possible, afin de ne pas garder des backdoors et des intrus présents dans le système pendant plus de 6 mois avant que les administrateurs ne le découvre.

&nbsp;
Enfin, n'oubliez pas que cette démarche est, dans un sens, très générale, mais dans un autre, plutôt spécifique à l'audit d'une application basée sur AMF. N'hésitez pas, si vous souhaitez plus de précision, à nous les poser en commentaire ou bien par [mail](mailto:quack1blog@gmail.com?subject=AMF Web App Pentesting) ;-)